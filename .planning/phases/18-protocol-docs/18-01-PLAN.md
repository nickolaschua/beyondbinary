---
phase: 18-protocol-docs
plan: 01
type: execute
---

<objective>
Document the WebSocket protocol for the sign detection endpoint so frontend developers can integrate without reading server source code.

Purpose: The frontend team needs a clear reference for connection lifecycle, message formats, and error codes. The WebSocket endpoint works but has no external documentation — integrators must read `ws_server.py` to understand the protocol.
Output: `docs/WEBSOCKET.md` documenting the complete WebSocket protocol.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context:
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Source of truth for protocol:
@ml/ws_server.py
@ml/utils.py

**Already complete (do not re-implement):**
- FastAPI lifespan context manager — `ws_server.py` lines 55-67
- Runtime keypoint shape assertion — `utils.py` line 156
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket protocol documentation</name>
  <files>docs/WEBSOCKET.md</files>
  <action>
  Create `docs/WEBSOCKET.md` documenting the complete WebSocket protocol by reading `ml/ws_server.py` and extracting the actual behavior. Document:

  **1. Connection**
  - Endpoint: `ws://{host}:{port}/ws/sign-detection`
  - Optional auth: `?api_key=KEY` query parameter (if SENSEAI_API_KEY is set)
  - Server accepts and begins per-connection state setup

  **2. Client -> Server Messages**
  - Frame message: `{"type": "frame", "frame": "<base64-jpeg>"}`
  - Frame requirements: base64-encoded JPEG, max 5MB, optional `data:image/jpeg;base64,` prefix

  **3. Server -> Client Messages**
  Document each response type with JSON schema:

  a) Buffering (not enough frames yet):
  ```json
  {
    "type": "buffering",
    "frames_collected": 15,
    "frames_needed": 30,
    "hands_detected": true
  }
  ```

  b) Sign prediction (buffer full, inference ran):
  ```json
  {
    "type": "sign_prediction",
    "sign": "Hello",
    "confidence": 0.9234,
    "is_stable": true,
    "is_new_sign": true,
    "hands_detected": true,
    "all_predictions": {"Hello": 0.9234, "Yes": 0.0412, ...},
    "frames_processed": 45,
    "total_inference_ms": 85.3
  }
  ```

  c) Error:
  ```json
  {
    "type": "error",
    "message": "Rate limit exceeded: max 60 frames per 10 seconds"
  }
  ```

  **4. Error Conditions**
  - Invalid JSON -> error message
  - Unknown message type -> error message
  - Rate limit exceeded (>60 frames in 10s) -> error message
  - Invalid frame data -> silently skipped (no response)
  - Payload >5MB -> silently skipped

  **5. Health Endpoint**
  - `GET /health` returns server status, model info, average inference time

  **6. Configuration**
  - Environment variables table: SENSEAI_HOST, SENSEAI_PORT, SENSEAI_CORS_ORIGINS, SENSEAI_CONFIDENCE_THRESHOLD, SENSEAI_STABILITY_WINDOW, SENSEAI_API_KEY

  **7. Stability Filter Behavior**
  - Explain how `is_stable` and `is_new_sign` work
  - N consecutive identical predictions above threshold required
  - `is_new_sign` only fires once per stable detection

  Read `ws_server.py` carefully to ensure all documented behavior matches the actual code. Do NOT document features that don't exist.
  </action>
  <verify>
  - Every JSON field in the docs exists in `ws_server.py`
  - Every error condition in the docs is handled in `ws_server.py`
  - No undocumented server behavior
  </verify>
  <done>docs/WEBSOCKET.md accurately documents the complete WebSocket protocol matching ws_server.py implementation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docs/WEBSOCKET.md` exists and is complete
- [ ] All message types documented with JSON examples
- [ ] Error conditions match actual server behavior
- [ ] Configuration env vars listed with defaults
- [ ] Stability filter behavior explained
- [ ] Health endpoint documented
</verification>

<success_criteria>

- WebSocket protocol fully documented
- A frontend developer can integrate using only the docs (no need to read ws_server.py)
- All documented behavior matches actual code
- Document follows project conventions (UPPERCASE.md for important docs)

</success_criteria>

<output>
After completion, create `.planning/phases/18-protocol-docs/18-01-SUMMARY.md`
</output>
