---
phase: 14-security-hardening
plan: 01
type: execute
---

<objective>
Harden the WebSocket server's remaining security gaps: restrict CORS to configurable origins, validate environment variable type conversions, and add optional API key authentication on WebSocket connect.

Purpose: The server currently allows any origin (`allow_origins=["*"]`) and crashes on invalid env var values (e.g., `SENSEAI_PORT=abc`). Rate limiting is already implemented. This plan closes the remaining security concerns identified in CONCERNS.md.
Output: CORS restricted via `SENSEAI_CORS_ORIGINS` env var, env var parsing wrapped in try/except with fallback, optional `SENSEAI_API_KEY` check on WebSocket handshake.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context:
@.planning/codebase/STACK.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

# Key source files:
@ml/utils.py
@ml/ws_server.py
@ml/tests/conftest.py
@ml/tests/test_ws_server.py
@ml/tests/test_config.py

**Already complete (do not re-implement):**
- Per-client frame rate limiting (60 frames/10s) — `ws_server.py` lines 159-162
- Payload size limit (5MB) — `decode_frame()` line 103
- Data URL validation — `decode_frame()` line 109
- Specific exception handling — `decode_frame()` lines 116-119

**Remaining gaps:**
1. CORS `allow_origins=["*"]` — any website can connect
2. `int()` / `float()` on env vars can crash with unhelpful error
3. No authentication mechanism on WebSocket endpoint
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add env var validation with safe fallbacks in utils.py</name>
  <files>ml/utils.py, ml/tests/test_config.py</files>
  <action>
  Wrap the env var conversions in `ml/utils.py` (lines 39-41) with try/except so invalid values fall back to defaults instead of crashing:

  ```python
  def _safe_int(env_key: str, default: int) -> int:
      raw = os.environ.get(env_key)
      if raw is None:
          return default
      try:
          return int(raw)
      except ValueError:
          return default

  def _safe_float(env_key: str, default: float) -> float:
      raw = os.environ.get(env_key)
      if raw is None:
          return default
      try:
          return float(raw)
      except ValueError:
          return default
  ```

  Then update the config lines:
  ```python
  HOST = os.environ.get("SENSEAI_HOST", "0.0.0.0")
  PORT = _safe_int("SENSEAI_PORT", 8001)
  CONFIDENCE_THRESHOLD = _safe_float("SENSEAI_CONFIDENCE_THRESHOLD", 0.7)
  STABILITY_WINDOW = _safe_int("SENSEAI_STABILITY_WINDOW", 8)
  ```

  Add tests in `ml/tests/test_config.py` for invalid env var values:
  - `SENSEAI_PORT=abc` -> falls back to 8001
  - `SENSEAI_CONFIDENCE_THRESHOLD=notanumber` -> falls back to 0.7
  - Valid values still work as before
  </action>
  <verify>
  - `python -m pytest tests/test_config.py -v` passes (including new tests)
  - Setting `SENSEAI_PORT=abc` does not crash on import
  </verify>
  <done>Env var conversions wrapped in try/except with safe fallbacks, tests added for invalid values</done>
</task>

<task type="auto">
  <name>Task 2: Make CORS origins configurable via environment variable</name>
  <files>ml/utils.py, ml/ws_server.py, ml/tests/test_config.py, ml/tests/test_ws_server.py</files>
  <action>
  1. Add a new constant in `ml/utils.py`:
     ```python
     CORS_ORIGINS = [
         origin.strip()
         for origin in os.environ.get("SENSEAI_CORS_ORIGINS", "*").split(",")
         if origin.strip()
     ]
     ```

  2. Import and use it in `ml/ws_server.py`:
     ```python
     from utils import (
         ...,
         CORS_ORIGINS,
     )
     ```

     Replace the hardcoded CORS middleware:
     ```python
     app.add_middleware(
         CORSMiddleware,
         allow_origins=CORS_ORIGINS,
         allow_credentials=True,
         allow_methods=["*"],
         allow_headers=["*"],
     )
     ```

  3. Add test in `test_config.py`:
     - Default (no env var) -> `["*"]`
     - `SENSEAI_CORS_ORIGINS=http://localhost:3000` -> `["http://localhost:3000"]`
     - `SENSEAI_CORS_ORIGINS=http://localhost:3000,http://example.com` -> both origins

  Behavior: In development, leave unset for `["*"]`. In production, set `SENSEAI_CORS_ORIGINS=https://your-frontend.com`.
  </action>
  <verify>
  - `python -m pytest tests/test_config.py -v` passes
  - CORS origins come from env var when set
  - Default behavior unchanged (still allows all origins)
  </verify>
  <done>CORS origins configurable via SENSEAI_CORS_ORIGINS, defaults to "*" for backwards compatibility</done>
</task>

<task type="auto">
  <name>Task 3: Add optional API key authentication on WebSocket connect</name>
  <files>ml/utils.py, ml/ws_server.py, ml/tests/test_ws_server.py</files>
  <action>
  1. Add to `ml/utils.py`:
     ```python
     API_KEY = os.environ.get("SENSEAI_API_KEY")  # None = auth disabled
     ```

  2. In `ml/ws_server.py`, import `API_KEY` and add auth check at the start of `sign_detection()`:
     ```python
     @app.websocket("/ws/sign-detection")
     async def sign_detection(websocket: WebSocket):
         # Optional API key auth
         if API_KEY is not None:
             key = websocket.query_params.get("api_key")
             if key != API_KEY:
                 await websocket.close(code=4003, reason="Invalid or missing API key")
                 return

         await websocket.accept()
         ...
     ```

     Client connects via: `ws://host:8001/ws/sign-detection?api_key=secret`

  3. Add tests in `test_ws_server.py`:
     - When `SENSEAI_API_KEY` is not set: connection accepted without key (no auth)
     - When `SENSEAI_API_KEY=secret`: connection with correct key accepted
     - When `SENSEAI_API_KEY=secret`: connection without key rejected (4003)
     - When `SENSEAI_API_KEY=secret`: connection with wrong key rejected (4003)

  Important: Auth is OFF by default (API_KEY=None). Only enabled when the env var is set. This preserves backwards compatibility for development and the hackathon demo.
  </action>
  <verify>
  - `python -m pytest tests/test_ws_server.py -v` passes (including new auth tests)
  - With no SENSEAI_API_KEY set, server accepts connections as before
  - With SENSEAI_API_KEY set, only matching keys connect
  </verify>
  <done>Optional API key auth on WebSocket, disabled by default, enabled via SENSEAI_API_KEY env var</done>
</task>

<task type="auto">
  <name>Task 4: Run full test suite</name>
  <files>ml/tests/</files>
  <action>
  Run the full test suite to ensure nothing is broken:
  ```bash
  cd ml && python -m pytest tests/ -x -q --tb=short
  ```

  All 114+ existing tests plus new tests must pass.
  </action>
  <verify>
  - All tests pass
  - No warnings about deprecated patterns
  </verify>
  <done>Full test suite passes with all new security hardening changes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Invalid env var values (e.g., SENSEAI_PORT=abc) fall back to defaults without crashing
- [ ] CORS origins configurable via SENSEAI_CORS_ORIGINS (defaults to "*")
- [ ] API key auth works when SENSEAI_API_KEY is set, disabled when unset
- [ ] Full test suite passes: `python -m pytest tests/ -x -q --tb=short`
- [ ] No backwards-incompatible changes (all defaults preserve current behavior)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Env var validation prevents crashes on invalid input
- CORS restricted to configurable origins
- Optional API key auth available for production use
- All existing + new tests pass
- Zero breaking changes to current development workflow

</success_criteria>

<output>
After completion, create `.planning/phases/14-security-hardening/14-01-SUMMARY.md`
</output>
